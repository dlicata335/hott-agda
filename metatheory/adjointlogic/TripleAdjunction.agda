
open import adjointlogic.Lib
open import adjointlogic.Rules
open import adjointlogic.Properties
open import adjointlogic.General

module adjointlogic.TripleAdjunction where

  -- ----------------------------------------------------------------------

  -- we want a triple adjunction 
  -- Δ -| Γ -| ∇

  -- this gives rise to 
  -- ♭ = ΔΓ 
  -- ♯ = ∇Γ 
  -- where ♭ -| #

  -- so we want 
  -- Δ -| ∇
  -- which is generated by ∇ o Δ having a unit and Δ o ∇ having a counit
  module TripleAdjunction (c : Mode)
                          (s : Mode)
                          (∇m : c ≥ s)
                          (Δm : s ≥ c)
                          (∇Δunit   : 1m ⇒ (∇m ∘1 Δm))
                          (Δ∇counit : (Δm ∘1 ∇m) ⇒ 1m) 

                          -- F -| G
                          -- F unit · counit F = 1 
                          -- unit G · G counit = 1   
                          (adjeq1 : ((1⇒{s}{c}{Δm} ∘1cong ∇Δunit) ·2 (Δ∇counit ∘1cong 1⇒{_}{_}{Δm})) == 1⇒)
                          (adjeq2 : ((∇Δunit ∘1cong  1⇒{_}{_}{∇m})  ·2 (1⇒{_}{_}{∇m} ∘1cong Δ∇counit)) == 1⇒)
                          where

    -- ----------------------------------------------------------------------
    -- F -| U so we want U Δ to be the same as F ∇

    mergeUF : ∀ {A : Tp c} → U Δm A [ 1m ]⊢ F ∇m A
    mergeUF = FR Δm Δ∇counit (UL 1m 1⇒ hyp) 

    mergeFU : ∀ {A : Tp c} → F ∇m A [ 1m ]⊢ U Δm A
    mergeFU = FL {α = ∇m} {β = 1m} (UR (transport⊢ ∇Δunit hyp))

    mergeUF-composite-1 : ∀ {A} → cut (mergeUF{A}) (mergeFU {A}) == ident (U Δm A)
    mergeUF-composite-1 = ap (UR {α = Δm} {β = 1m ∘1 1m}) (UL2 {α = Δm} {β = 1m ∘1 (Δm ∘1 1m)} {γ = ∇m ∘1 Δm} {γ' = 1m} {e = (1⇒ ∘1cong 1⇒) ·2 (Δ∇counit ∘1cong 1⇒)} {e' = 1⇒} {D = transport⊢ ∇Δunit hyp} {D' = hyp} ∇Δunit adjeq1 id ∘ (ap (UL (∇m ∘1 Δm) (Δ∇counit ∘1cong 1⇒)) (cut-ident-left (transport⊢ ∇Δunit hyp)) ∘ ap (transport⊢ (Δ∇counit ∘1cong 1⇒)) (cutUL {e = 1⇒} {D = hyp} (transport⊢ ∇Δunit hyp))) ) 

    mergeUF-composite-2 : ∀ {A} → cut (mergeFU {A}) (mergeUF{A}) == ident (F ∇m A)
    mergeUF-composite-2 = ap (FL {α = ∇m} {β = 1m ∘1 1m}) (FR2 ∇Δunit adjeq2 (((cut-ident-right _ ∘ transport⊢1 _) ∘ cut-ident-left _) ∘ transport⊢1 _)) ∘ Fη _ 

    mergeUFqeq : ∀ {A} → QEquiv (U Δm A) (F ∇m A)
    mergeUFqeq = qequiv mergeUF mergeFU mergeUF-composite-1 mergeUF-composite-2

    {- these should not be provable
    badmergeUF : ∀ {A : Tp s} → U ∇m A [ 1m ]⊢ F Δm A
    badmergeUF = UL Δm {!NO!} (FR 1m 1⇒ hyp)
  
    badmergeUF' : ∀ {A : Tp s} → U ∇m A [ 1m ]⊢ F Δm A
    badmergeUF' = FR ∇m {!NO!} (UL 1m 1⇒ hyp) 
  
    badmergeFU : ∀ {A : Tp s} → F Δm A [ 1m ]⊢ U ∇m A
    badmergeFU = FL (UR (transport⊢ {!NO!} hyp))
    -}

    -- -------------------------------------------------------------------------------

    ♭ = □ Δm
    ♯ = ◯ ∇m

    {- these should not be provable
    badunit' : {A : Tp c}→ A [ 1m ]⊢ ♭ A
    badunit' = FR ∇m {! NO!} (UR (transport⊢ {!!} hyp))
  
    badcounit' : {A : Tp c} → ♯ A [ 1m ]⊢ A
    badcounit' = UL Δm {! NO!} (FL (transport⊢ {!!} hyp))
    -}

    -- they are adjoint

    ♭♯adjunction1 : ∀ {A B} → ♭ A [ 1m ]⊢ B → A [ 1m ]⊢ ♯ B
    ♭♯adjunction1 {A}{B} start = UFadjunction1 step2 where
      step1 : U Δm A [ 1m ]⊢ U Δm B
      step1 = UFadjunction1 start
  
      step2 : F ∇m A [ 1m ]⊢ F ∇m B
      step2 = cut (cut mergeFU step1) mergeUF

    ♭♯adjunction2 : ∀ {A B} → A [ 1m ]⊢ ♯ B → ♭ A [ 1m ]⊢ B 
    ♭♯adjunction2 {A}{B} start = UFadjunction2 (cut mergeUF (cut (UFadjunction2 start) mergeFU))

    -- these should be an equivalence 

    -- ----------------------------------------------------------------------
    -- ♭ preserves coproducts

    pres-coprod1 : ∀ {A B} → ♭ (A ⊕ B) [ 1m ]⊢ (♭ A ⊕ ♭ B)
    pres-coprod1 = ♭♯adjunction2 (Case (♭♯adjunction1 (Inl hyp)) (♭♯adjunction1 (Inr hyp)))

    pres-coprod2 : ∀ {A B} → (♭ A ⊕ ♭ B) [ 1m ]⊢ ♭ (A ⊕ B)
    pres-coprod2 = Case (□func (Inl hyp)) (□func (Inr hyp))

    {- FIXME 
    pres-coprod2-composite-1 : cut (pres-coprod1 {P}{Q}) (pres-coprod2 {P}{Q}) == hyp
    pres-coprod2-composite-1 = {!!}

    pres-coprod2-composite-2 : cut (pres-coprod2 {P}{Q}) (pres-coprod1 {P}{Q}) == hyp
    pres-coprod2-composite-2 = {!!}
    -}
    
    -- ----------------------------------------------------------------------
    -- ♭ absorbing ♯ and vice versa: 
    -- for this theory, ♭ A is a retract of ♭ (♯ A) and ♯ A is a retract of ♯ (♭ A)
    
    ♭absorbs♯1 : ∀ {A} → ♭ A [ 1m ]⊢ ♭ (♯ A) 
    ♭absorbs♯1 = □func ◯unit

    ♭absorbs♯2 : ∀ {A} → ♭ (♯ A) [ 1m ]⊢ ♭ A
    ♭absorbs♯2 = FL {α = Δm} {β = 1m} (FR 1m 1⇒ (UL ∇m Δ∇counit (UL 1m 1⇒ mergeFU))) 

    ♭absorbs♯-composite-1 : cut (♭absorbs♯1 {P}) (♭absorbs♯2 {P}) == hyp
    ♭absorbs♯-composite-1 = ap (λ x → FL (FR 1m 1⇒ x)) (ap (UR {α = Δm} {β = 1m}) (UL2 {D = cut (UR (hypp ∇Δunit)) (UL 1m 1⇒ hyp)} {D' = ident P} ∇Δunit adjeq1 id) ∘ Uη (UL ∇m Δ∇counit (UR (hypp ∇Δunit))))

    ♯absorbs♭1 : ∀ {A} → ♯ A [ 1m ]⊢ ♯ (♭ A) 
    ♯absorbs♭1 = UR {α = ∇m} {β = 1m} (UL 1m 1⇒ (FR Δm Δ∇counit (FR 1m 1⇒ mergeFU))) 

    ♯absorbs♭2 : ∀ {A} → ♯ (♭ A) [ 1m ]⊢ ♯ A
    ♯absorbs♭2 = ◯func □counit

    ♯absorbs♭-composite-1 : cut (♯absorbs♭1 {P}) (♯absorbs♭2 {P}) == hyp
    ♯absorbs♭-composite-1 = ap (λ x → UR {α = ∇m} {β = 1m} (UL 1m 1⇒ x)) (ap (FL { α = ∇m} {β = 1m}) (FR2 {D = cut (FR 1m 1⇒ hyp) (FL (hypp ∇Δunit))} {D' = ident P} ∇Δunit adjeq2 id) ∘ Fη (FR Δm Δ∇counit (FL (hypp ∇Δunit))))
