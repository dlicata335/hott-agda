
open import adjointlogic.Lib
open import adjointlogic.Rules
open import adjointlogic.Properties
open import adjointlogic.General

module adjointlogic.TripleAdjunction where

  -- ----------------------------------------------------------------------

  -- we want a triple adjunction 
  -- Δ -| Γ -| ∇

  -- this gives rise to 
  -- ♭ = ΔΓ 
  -- ♯ = ∇Γ 
  -- where ♭ -| #

  -- so we want 
  -- Δ -| ∇
  -- which is generated by ∇ o Δ having a unit and Δ o ∇ having a counit
  module TripleAdjunction (c : Mode)
                          (s : Mode)
                          (∇m : c ≥ s)
                          (Δm : s ≥ c)
                          (∇Δunit   : 1m ⇒ (∇m ∘1 Δm))
                          (Δ∇counit : (Δm ∘1 ∇m) ⇒ 1m) 

                          -- F -| G
                          -- F unit · counit F = 1 
                          -- unit G · G counit = 1   
                          (adjeq1 : ((1⇒{s}{c}{Δm} ∘1cong ∇Δunit) ·2 (Δ∇counit ∘1cong 1⇒{_}{_}{Δm})) == 1⇒)
                          (adjeq2 : ((∇Δunit ∘1cong  1⇒{_}{_}{∇m})  ·2 (1⇒{_}{_}{∇m} ∘1cong Δ∇counit)) == 1⇒)
                          where

    -- ----------------------------------------------------------------------
    -- F -| U so we want U Δ to be the same as F ∇
    -- we actually get an "hiso" -- a map with both a left and a right inverse, but they're different

    mergeUF : ∀ {A : Tp c} → U Δm A [ 1m ]⊢ F ∇m A
    mergeUF = FR Δm Δ∇counit (UL 1m 1⇒ hyp) 

    mergeUF' : ∀ {A : Tp c} → U Δm A [ 1m ]⊢ F ∇m A 
    mergeUF' = UL ∇m Δ∇counit (FR 1m 1⇒ hyp)

    mergeFU : ∀ {A : Tp c} → F ∇m A [ 1m ]⊢ U Δm A
    mergeFU = FL {α = ∇m} {β = 1m} (UR (transport⊢ ∇Δunit hyp))

    inv1 : cut (mergeUF{P}) (mergeFU {P}) == ident (U Δm P)
    inv1 = ap (UR {α = Δm} {β = 1m ∘1 1m}) (UL2 {D = cut hyp (hypp ∇Δunit)} {D' = ident P} ∇Δunit adjeq1 id) 

    inv2 : cut (mergeFU {P}) (mergeUF'{P}) == ident (F ∇m P)
    inv2 = ap (FL {α = ∇m} {β = 1m ∘1 1m}) (FR2 {D = cut (hypp ∇Δunit) hyp} {D' = ident P} ∇Δunit adjeq2 id) 

    {- these should not be provable
    badmergeUF : ∀ {A : Tp s} → U ∇m A [ 1m ]⊢ F Δm A
    badmergeUF = UL Δm {!NO!} (FR 1m 1⇒ hyp)
  
    badmergeUF' : ∀ {A : Tp s} → U ∇m A [ 1m ]⊢ F Δm A
    badmergeUF' = FR ∇m {!NO!} (UL 1m 1⇒ hyp) 
  
    badmergeFU : ∀ {A : Tp s} → F Δm A [ 1m ]⊢ U ∇m A
    badmergeFU = FL (UR (transport⊢ {!NO!} hyp))
    -}

    -- -------------------------------------------------------------------------------

    ♭ = □ Δm
    ♯ = ◯ ∇m

    {- these should not be provable
    badunit' : {A : Tp c}→ A [ 1m ]⊢ ♭ A
    badunit' = FR ∇m {! NO!} (UR (transport⊢ {!!} hyp))
  
    badcounit' : {A : Tp c} → ♯ A [ 1m ]⊢ A
    badcounit' = UL Δm {! NO!} (FL (transport⊢ {!!} hyp))
    -}

    -- they are adjoint

    ♭♯adjunction1 : ∀ {A B} → ♭ A [ 1m ]⊢ B → A [ 1m ]⊢ ♯ B
    ♭♯adjunction1 {A}{B} start = UFadjunction1 step2 where
      step1 : U Δm A [ 1m ]⊢ U Δm B
      step1 = UFadjunction1 start
  
      step2 : F ∇m A [ 1m ]⊢ F ∇m B
      step2 = cut (cut mergeFU step1) mergeUF

    ♭♯adjunction2 : ∀ {A B} → A [ 1m ]⊢ ♯ B → ♭ A [ 1m ]⊢ B 
    ♭♯adjunction2 {A}{B} start = UFadjunction2 (cut mergeUF (cut (UFadjunction2 start) mergeFU))

    -- one of these should be a mergeUF' and then these should be an equivalence 

    -- ----------------------------------------------------------------------
    -- ♭ preserves coproducts

    pres-coprod1 : ∀ {A B} → ♭ (A ⊕ B) [ 1m ]⊢ (♭ A ⊕ ♭ B)
    pres-coprod1 = ♭♯adjunction2 (Case (♭♯adjunction1 (Inl hyp)) (♭♯adjunction1 (Inr hyp)))

    pres-coprod2 : ∀ {A B} → (♭ A ⊕ ♭ B) [ 1m ]⊢ ♭ (A ⊕ B)
    pres-coprod2 = Case (□func (Inl hyp)) (□func (Inr hyp))

    {- FIXME 
    pres-coprod2-composite-1 : cut (pres-coprod1 {P}{Q}) (pres-coprod2 {P}{Q}) == hyp
    pres-coprod2-composite-1 = {!!}

    pres-coprod2-composite-2 : cut (pres-coprod2 {P}{Q}) (pres-coprod1 {P}{Q}) == hyp
    pres-coprod2-composite-2 = {!!}
    -}
    
    -- ----------------------------------------------------------------------
    -- ♭ absorbing ♯ and vice versa: 
    -- for this theory, ♭ A is a retract of ♭ (♯ A) and ♯ A is a retract of ♯ (♭ A)
    
    ♭absorbs♯1 : ∀ {A} → ♭ A [ 1m ]⊢ ♭ (♯ A) 
    ♭absorbs♯1 = □func ◯unit

    ♭absorbs♯2 : ∀ {A} → ♭ (♯ A) [ 1m ]⊢ ♭ A
    ♭absorbs♯2 = FL {α = Δm} {β = 1m} (FR 1m 1⇒ (UL ∇m Δ∇counit (UL 1m 1⇒ mergeFU))) 

    ♭absorbs♯-composite-1 : cut (♭absorbs♯1 {P}) (♭absorbs♯2 {P}) == hyp
    ♭absorbs♯-composite-1 = ap (λ x → FL (FR 1m 1⇒ x)) (ap (UR {α = Δm} {β = 1m}) (UL2 {D = cut (UR (hypp ∇Δunit)) (UL 1m 1⇒ hyp)} {D' = ident P} ∇Δunit adjeq1 id) ∘ Uη (UL ∇m Δ∇counit (UR (hypp ∇Δunit))))

    ♯absorbs♭1 : ∀ {A} → ♯ A [ 1m ]⊢ ♯ (♭ A) 
    ♯absorbs♭1 = UR {α = ∇m} {β = 1m} (UL 1m 1⇒ (FR Δm Δ∇counit (FR 1m 1⇒ mergeFU))) 

    ♯absorbs♭2 : ∀ {A} → ♯ (♭ A) [ 1m ]⊢ ♯ A
    ♯absorbs♭2 = ◯func □counit

    ♯absorbs♭-composite-1 : cut (♯absorbs♭1 {P}) (♯absorbs♭2 {P}) == hyp
    ♯absorbs♭-composite-1 = ap (λ x → UR {α = ∇m} {β = 1m} (UL 1m 1⇒ x)) (ap (FL { α = ∇m} {β = 1m}) (FR2 {D = cut (FR 1m 1⇒ hyp) (FL (hypp ∇Δunit))} {D' = ident P} ∇Δunit adjeq2 id) ∘ Fη (FR Δm Δ∇counit (FL (hypp ∇Δunit))))
