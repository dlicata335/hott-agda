
\section{Overview of the Proof}

\subsection{Definition of the Spheres}

We define the $n$-dimensional sphere $S^n$ as the higher inductive type
generated by one point \dsd{base} and one point in the $n^{th}$ loop space
of $S^n$ at \dsd{base}:

\[
\begin{array}{l}
\dsd{base}_n : S^n \\
\dsd{loop}_n : \Omega^n(S^n,\dsd{base}) \\
\end{array}
\]

The corresponding elimination rule, \emph{sphere recursion}, says that
to define a function $S^n \to C$, it suffices to give a point $c:C$ and
a loop in $\Omega^n(C,c)$:
\[
\infer{\tptm {\Srec n C c p} {S^n \to C} }
      {C : \dsd{Type} & c : C & p : \Omega^n(C,c)}
\]
The computation rules for this elimination rule are as follows:
\[
\begin{array}{l}
\Srec n C c p \dsd{base}_n :\equiv c \\
\dsd{ap}^n (\Srec n C c p) \dsd{loop}_n := p 
\end{array}
\]
where $\dsd{ap}^n$ applies a function $f : A \to B$ to an
$n$-dimensional loop in $\Omega^n(A,a)$ to get an $n$-dimensional loop
in $\Omega^n(B,f a)$.  We discuss the definition of $\Omega^n(X,x_0)$
and $ap^n$ in Section~\ref{sec:loopspace} below.

We also require a dependent elimination rule, \emph{sphere
induction}:
\[
\infer{\tptm {\Selim n C c p} {\picl{x}{S^n}{C(x)}} }
      {C : S^n \to \dsd{Type} & c : C(\dsd{base}) & p : \Omega^n_{\dsd{loop_n}}(C,c)}
\]
Here, the type $\Omega^n_{p}(C,c)$ represents an ``$n$-dimensional
loop-over-a-loop''; it is well-formed when $C : A \to Type$ and 
$p : \Omega^n(A,a)$ and $c : C(a)$ (for some $A$ and $a$).  Topologically, it represents an
$n$-dimensional path at $c$ in
the total space of $C$ that projects down to $p$.  We discuss the
definition of $\Omega^n_{p}(C,c)$ in Section~\ref{sec:loopspace} below.  
The computation rules
for sphere induction are similar to those for sphere recursion.   

Note that the constructor $\dsd{loop}_n$ is a path whose level depends
on $n$: for $n = 1$, it is a path, for $n = 2$, it is a path between
paths, and so on.  Because of this, the above definition of $S^n$ does
not fall into any of the schemas for higher inductive types that have
been formally studied.  However, it seems like a sensible notion,
because for any fixed $n$, it expands to a type a higher inductive
constructor would be permitted to have: For $n = 1$, it is $\dsd{base}
=_{S^1} \dsd{base}$, for $n=2$, it is $\dsd{id} =_{\dsd{base} =_{S^2}
  \dsd{base}} \dsd{id}$, and so on.  All of these are iterated identity
types in $S^n$, which is the type being defined.  We leave it to future
work to justify this kind of definition semantically.  Another
possible justification would be to take the above rules not as a specification of a
higher-inductive type, but as an interface, and implement it by the
 definition of $S^n$ by iterated suspension~\citep[Section 6.5]{uf13hott-book}.  

\subsection{Calculation of $\pi_n(S^n)$}

We now describe the calculation that $\pi_n(S^n) = \mathbb{Z}$.\footnote{We
write $\pi_n(X)$ for $\pi_n(X,x_0)$ (and similarly for $\Omega$) when the
base point is clear from context.  For the spheres, if we elide the base
point, it is
the constructor $\dsd{base}_n$.}  Formally, this statement means
that there is a group isomorphism between the group $\pi_n(S^n)$ (with
composition as the group operation) and the additive group
$\mathbb{Z}$.  In what follows, we will discuss the proof that the
\emph{type} $\pi_n(S^n)$ is equivalent (and hence equal, by univalence) to the
type $\mathbb{Z}$, and omit the proof that this equivalence sends
composition to addition.   

The
first step is an induction on $n$.  In the base case, we use the
homotopy type theory proof of $\pi_1(S^1) = \mathbb{Z}$ described in
previous work~\citep{ls13pi1s1}.  In the inductive step, the key lemma
is that $\pi_{n+1}(S^{n+1}) = \pi_n(S^n)$, which, combined with the
inductive hypothesis gives the result.  

To show that $\pi_{n+1}(S^{n+1}) = \pi_n(S^n)$, we calculate as
follows:\footnote{We use the convention of eliding the base point
  heavily here.  The base point of $\Omega(A)$ is $\dsd{id}_a$, when
  $a$ is the base point of $A$.  The base point of $||A||_k$ is $|a|$,
  where $a$ is the base point of $A$, and $|-|$ is the constructor for
  the $n$-truncation type $||A||_n$~\citep[Section 7.3]{uf13hott-book}.}

\[
\begin{array}{rcll}
\pi_{n+1}(S^{n+1}) & = & ||\Omega^{n+1}(S^{n+1})||_0 & \text{definition}\\
                  & = & ||\Omega^{n}(\Omega(S^{n+1}))||_0 & \text{unfold $\Omega^{n+1}$} \\
                  & = & \Omega^{n}(||\Omega(S^{n+1})||_n) & \text{swap truncation and loop space} \\
                  & = & \Omega^{n}(||S^{n}||_n) & \text{main lemma} \\
                  & = & ||\Omega^{n}(S^{n})||_0 & \text{swap truncation and loop space} \\
                  & = & \pi_n(S^n) & \text{definition} \\
\end{array}
\]

Several of these steps are relatively easy lemmas.  For example, we can
unfold $\Omega^{n+1}(X)$ as $\Omega^n(\Omega(X))$---one might
take this as the definition of $\Omega^{n+1}$, but for the definition
below it is a lemma.  Additionally, there is a rule for swapping
a truncation with a loop space, incrementing the index:
\[
||\Omega(X)||_n = \Omega(||X||_{n+1})
\]
Intuitively, $||\Omega(X)||_n$ is a type built from $\Omega(X)$ by
equating all $(n+1)$-cells in $\Omega(X)$.  However, $\Omega(X)$ is the
space of 1-cells (paths) in $X$, so the $(n+1)$-cells in $\Omega(X)$ are the
$(n+2)$-cells in $X$.  Thus, it is equivalent to equate all $(n+2)$-cells in
$X$, and then take the loop space.  Iterating this reasoning gives the
equation used above, that
\[
||\Omega^n(X)||_0 = \Omega^n(||X||_{n})
\]

This reasoning reduces the problem to proving the main lemma, that 
\[
||\Omega(S^{n+1})||_n = ||S^{n}||_n
\]
That is, the loop space on the $(n+1)$-sphere is equivalent to the
$n$-sphere, when appropriately truncated.  $\Omega(S^{n+1})$ is, by
definition, the type $\dsd{base}_{n+1} =_{S^{n+1}} \dsd{base}_{n+1}$, 
so this lemma is characterizing (the truncation of) a path space of a
higher-inductive type.  A general template for doing such
characterizations is the 
\emph{encode-decode method}~\citep[Section 8.9]{uf13hott-book}, which we
apply here.  

\subsection{The encode-decode argument}
\label{sec:encode-decode}

The bulk of the proof consists of proving that $||\Omega(S^{n+1})||_n =
||S^{n}||_n$.  To build intuition, consider the case of
$||\Omega(S^2)||_1 = ||S^1||_1$.  Setting aside the truncations for the
moment, this means we are comparing points on $S^1$ (the circle) with
loops on $S^2$ (the sphere).  The idea is to set up a correspondence
where the base point of the circle ($\dsd{base_1}$) corresponds to the
constant path at the base point of the sphere ($\dsd{id}_{\dsd{base}_2}$), and
going $n$ times around the loop of the circle ($\dsd{loop}_1^n$)
corresponds to going $n$ times around the surface of the sphere
($\dsd{loop}_2^n$).  In classical topology, it is clear that this
correspondence induces a bijection between the set of points on the
circle and the set of loops on the sphere (both considered up to
homotopy): the circle has one connected component, and any loop on the
sphere can be contracted to the constant loop.  Moreover, it induces a
bijection between the set of loops on the circle and the set of 2-loops
on the sphere (again considered up to homotopy), because \emph{every}
loop on the circle is $\dsd{loop}^n$ for some $n$, and \emph{every}
2-loop on the sphere is $\dsd{loop}_2^n$ for some $n$. While proving
these facts is essentially what we are doing in this section, it should
at least be intuitively plausible that the points and loops on the
circle are the same as the loops and 2-dimensional loops on the sphere.
But the loops and 2-dimensional loops on the sphere are the points and
loops of the loop space of the sphere, $\Omega(S^2)$, so the points and
loops of $S^1$ are the same as the points and loops of $\Omega(S^2)$.

However, it is not the case that $S^1$ and $\Omega(S^2)$ are equivalent
types, because $S^2$ has non-trivial 3-dimensional paths, while $S^1$
has only trivial 2-dimensional paths.  Thus, the situation is that the
points and paths of $S^1$ are in correspondence with the points and
paths of $\Omega(S^2)$, but the correspondence does not extend to higher
dimensions.  The role of the truncation is to account for this
difference.  Comparing $||S^1||_1$ with $||\Omega(S^2)||_1$ considers
only points and paths, not any higher-dimensional cells, and restricted
to points and paths the above correspondence is in fact an equivalence.

To prove the lemma, we proceed as follows.  First, we define a map $S^n \to
\Omega(S^{n+1})$ by sphere recursion, where 
\[
\begin{array}{l}
\dsd{promote} : S^n \to \Omega(S^{n+1}) \\
\dsd{promote}(\dsd{base}_n) :\equiv \dsd{id}_{\dsd{base}_{n+1}} \\
\dsd{ap}^n \: \dsd{promote} \: (\dsd{loop}_n) := \dsd{loop}_{n+1}
\end{array}
\]
In the third line, we omit a coercion from $\Omega^{n+1}(S^{n+1})$, the type
of $\dsd{loop}_{n+1}$, to the required type $\Omega^n(\Omega(S^{n+1}))$---$\dsd{loop}_{n+1}$ can be seen
as an $n$-dimensional loop in $\Omega(S^{n+1})$.
This is one direction of the correspondence described above, which
sends, for example, loops on the circle to 2-dimensional loops on the
sphere.  Because functions are functors, we specify only the action on
the generators $\dsd{base}_n$ and $\dsd{loop}_n$; the function automatically
preserves identity, composition, etc., and thus, for example, takes the $n$-fold
composition $\dsd{loop}_1^n$ to the $n$-fold composition
$\dsd{loop}_2^n$, as desired.  Thinking of $S^{n+1}$ as the
suspension of $S^n$, this is the meridan map of the
suspension, which embeds $X$ into $\Omega(\Sigma X)$---i.e. it's the unit of
the suspension/loop space adjunction.

Because truncation is functorial, this map extends to a map $||S^n||_n
\to ||\Omega(S^{n+1})||_n$:
\[
\begin{array}{l}
\dsd{decode'} : ||S^n||_n \to ||\Omega(S^{n+1})||_n \\
\dsd{decode'}(|x|) = |\dsd{promote}(x)|
\end{array}
\]
(where peeling off the truncation is permitted by
truncation-elimination, because $||-||_n$ is an $n$-type).

We would like to show that this map is an equivalence.  To define the
inverse map $||\Omega(S^{n+1})||_n \to ||S^n||_n$, we need to define a
map out of (the truncation of) a path space.  One central tool for doing
this is univalence: we define a map from $S^{n+1}$ into the universe, so
that the base point of $S^{n+1}$ is sent to $||S^n||_n$ and paths in $S^{n+1}$
are sent to equivalences, and then we apply the
equivalence determined by a loop to the base point of $||S^n||_n$.  In
this case, we define a fibration \dsd{Codes} by sphere recursion
\[
\begin{array}{l}
\dsd{Codes} : S^{n+1} \to \dsd{Type} \\
\dsd{Codes}(\dsd{base}_{n+1}) :\equiv ||S^{n}||_n \\
\dsd{ap}^n \: \dsd{Codes} \: (\dsd{loop}_{n+1}) := (\ldots : \Omega^{n+1}(\dsd{Type},||S^{n}||_n)) \\
\end{array}
\]
The fiber over the base point is $||S^{n}||_n$, so \dsd{Codes} will send
an element of $\Omega(S^{n+1})$ (which, recall, is notation for $\dsd{base}_{n+1}
=_{S^{n+1}} \dsd{base}_{n+1}$) to an equivalence $||S^{n}||_n \simeq
||S^{n}||_n$.  Thus, we can define a function $\dsd{encode'} : ||\Omega(S^{n+1})||_n \to
||S^n||_n$ by applying $\dsd{Codes}$ to the given path (after peeling
off the truncation brackets, which is allowed because the result is an $n$-type), and then
applying the resulting equivalence to $|\dsd{base}_n|$:
\[
\begin{array}{l}
\dsd{encode'} : ||\Omega(S^{n+1})||_n \to ||S^n||_n \\
\dsd{encode'}(|p|) = (\dsd{ap}(\dsd{Codes}) p) |\dsd{base}_n|
\end{array}
\]

Eliding truncations for a moment, the term $\dsd{ap}^n(\dsd{encode'})$
is a function from $\Omega^n(\Omega(S^{n+1}))$ to $\Omega^n(S^n)$, so it
determines\footnote{Recall that $\Omega^{n+1} =
  \Omega^n(\Omega(X))$ is a lemma, rather than a definitional equality,
  for our definition of $\Omega^n$} a function from $\Omega^{n+1}(S^{n+1})$ to
$\Omega^n(S^n)$.  Because we would like \dsd{encode'}
to be inverse to \dsd{decode'}, we need to fill in the $\ldots$ in the
definition of \dsd{Codes} so that $\dsd{ap}^n \: \dsd{encode'}$ sends
$\dsd{loop}_{n+1}$ to $\dsd{loop}_n$ (modulo truncations and the
equivalence expanding $\Omega^{n+1}$).  Thus, we need an element of
$\Omega^{n+1}(\dsd{Type},||S^n||_n)$ that is somehow determined by 
$\dsd{loop}_n$, so that we get $\dsd{loop}_n$ back out when we apply it.  

The key maneuver is to apply an equivalence between
$\Omega^{n+1}(\dsd{Type},A)$ and $\picl{x}{A}{}{\Omega^n(A,x)}$
(discussed below).  That is,
an $n+1$-dimensional loop in the space of types with base point $A$ is
the same as a family of $n$-dimensional loops in $A$, given for each
point in $A$.  This reduces the problem to giving an element of type
\[
\picl{x}{||S^n||_n}{}{\Omega^n(||S^n||_n,x)}
\]
which (modulo some truncation manipulation) is defined by
sphere-elimination, sending $\dsd{base}_n$ to $\dsd{loop}_n$, and
proving that this choice respects $\dsd{loop}_n$.  For $n=1$, a small
calculation is needed to prove this final condition, and for any greater $n$
it is trivial by truncation reasons.  This ``packages up''
$\dsd{loop}_n$ in the \dsd{Codes} fibration in such a way that
\dsd{encode'} extracts it.    

Now that we have defined \dsd{encode'} and \dsd{decode'}, the task is to
show that they are mutually inverse.  The remaining steps required to do
so are as follows:
\begin{itemize}
\item First, we do a calculation to show that
  $\dsd{encode'}(\dsd{decode'} c) = c$.  The proof uses
  sphere-elimination, and calculations with the loop space
  library---this is where we prove that \dsd{encode'} takes
  $\dsd{loop}_{n+1}$  to $\dsd{loop}_n$.

\item The definition of \dsd{encode'} given above in fact has a more
  general type: it works not only for loops, but for paths to any
  endpoint $x$:
\[
\begin{array}{l}
\dsd{encode} : \picl{x}{S^{n+1}}{} (\dsd{base}_{n+1} =_{S^{n+1}} x) \to \dsd{Codes}(x)\\
\dsd{encode}(|p|) = (\dsd{ap}(\dsd{Codes}) p) |\dsd{base}_n|
\end{array}
\]

\item Through a somewhat involved calculation with the loop space library,
  we can show that \dsd{decode'} extends to a function

\[
\dsd{decode} : \picl{x}{S^{n+1}}{} \dsd{Codes}(x) \to (\dsd{base}_{n+1} =_{S^{n+1}} x)
\]
This function is defined by sphere elimination; 
when $x$ is $\dsd{base}_{n+1}$, the function is \dsd{decode'}; then
we have to prove that this choice respects the \dsd{loop}. 

\item Now that we have generalized to \dsd{encode} and \dsd{decode}, it
  is easy to show that 
  \[
  \Pi x : S^{n+1}, p : || \dsd{base}_{n+1} = x ||.  \dsd{decode}_x(\dsd{encode}_x(p)) = p
  \] by path
  induction, because on the identity path, it is true by definition.
\end{itemize}
%
The details of these steps are somewhat intricate, so we refer the
reader to the Agda proof.  

\subsection{Loop space library}
\label{sec:loopspace}

Next, we give a brief overview of some of the key lemmas in the loop
space library.

\subsubsection{Definitions, groupoid and functor structure}
First, we define
\[
\begin{array}{l}
\Omega(X : \dsd{Type},x_0 : X) : \dsd{Type}\\
\Omega(X,x_0) :\equiv x_0 =_X x_0 \\
\\
\Omega^{n \ge 1}(X : \dsd{Type} , x_0 : X) : \dsd{Type}\\
\Omega^1(X,x_0) :\equiv \Omega(X,x_0) \\
\Omega^{1+n}(X,x_0) :\equiv \Omega(\Omega^n(X,x_0), \dsd{id}^n) \\
\\ 
\dsd{id}^n : \Omega(X,x_0) \\
\dsd{id}^1 :\equiv \dsd{id}_{x_0} \\
\dsd{id}^{1+n} :\equiv \dsd{id}_{\dsd{id}^n} \\
\end{array}
\]
That is, we define $\Omega^n$ mutually with a point $\dsd{id}^n$ of it.   
This definition unfolds as $\Omega^{1+n}(X) = \Omega(\Omega^n(X))$.  An
alternative is to define

\[
\begin{array}{l}
\Omega'^1(X,x_0) :\equiv \Omega(X,x_0) \\
\Omega'^{1+n}(X,x_0) :\equiv \Omega'^n(\Omega(X),\dsd{id}_{x_0})
\end{array}
\]
i.e. $\Omega'^{1+n}(X) = \Omega'^n(\Omega(X))$.  In the library, we
prove that these two definitions are equivalent, so we can unfold
$\Omega^{1+n}$ in both ways.  The current loop space library takes
$\Omega$ as the main definition and uses $\Omega'$ as an auxilary
notion.  However, since the different definitions have different   
definitional behaviors, it would be interesting to try revising the
library based on taking $\Omega'$ as the main notion, to see if it is
simpler or not.  

In addition to $\dsd{id}^n$, there are also inverse and composition
operations on each loop space:
\[
\begin{array}{l}
!^n (l : \Omega^n(X,x_0)) : \Omega^n(X,x_0) \\
(l_1 : \Omega^n(X,x_0)) \comp^n (l_2 : \Omega^n(X,x_0)) : \Omega^n(X,x_0)
\end{array}
\]
We prove various groupoid laws for these operations (unit, involution).

Many loop space operations are  defined by induction on $n$.  For
example, consider applying a function to a loop.  Intuitively, the idea
is that $\dsd{ap}^n \: f \: l$ iterates \dsd{ap} to apply $f$ at the
appropriate level.  For example, $\dsd{ap}^2 \: f$ should be $\dsd{ap}
(\dsd{ap} \: f)$, while $\dsd{ap}^3 \: f$ should be $\dsd{ap}
(\dsd{ap} \: (\dsd{ap} \: f))$.  In general, it is defined as follows:
\[
\begin{array}{l}
\dsd{ap}^n (f : X \to Y) (l : \Omega^n(X,x_0)) : \Omega^n(Y,f x_0) \\
\dsd{ap}^1 \: f \: l :\equiv \dsd{ap} f l \\
\dsd{ap}^{1+n} \: f \: l :\equiv \dsd{ap^n\text{-}id } \comp \dsd{ap} (\dsd{ap}^n f) l \comp (! \dsd{ap^n\text{-}id }) \\
\end{array}
\]
In the $1+n$ case, $l : \Omega(\Omega^n(X))$.  The recursive call
$\dsd{ap}^n f$ has type $\Omega^n(X,x_0) \to \Omega^n(Y, f(x_0))$.  Thus, 
using \dsd{ap} to apply this to the path $l$ gives an element of 
\[
\dsd{ap}^n \: f \: \dsd{id}^n = \dsd{ap}^n \: f \: \dsd{id}^n
\]
We require an element of $\dsd{id}^{n} = \dsd{id}^n$, so we compose on
both sides with a proof \dsd{ap^n\text{-}id} that $\dsd{ap}^n$
preserves identities.  Many definitions on $\Omega^n$ follow this
template: an induction on $n$, defined mututally with a lemma stating
preservation of identities.  $\dsd{ap}^n$ also preserves inverses and
composition, and is functorial in the function position:
\[
\begin{array}{l}
\dsd{ap}^n(\lambda x.x) l = l \\
\dsd{ap}^n(g \comp f) l = \dsd{ap}^n \: g (\dsd{ap}^n \: f \: l) 
\end{array}
\]
Another key lemma is that $\dsd{ap}^{1+n}$ can be unfolded in the other
assocativity: above, we essentially defined $\dsd{ap}^{1+n} =
\dsd{ap}(\dsd{ap}^n f)$.  Using the equivalence between $\Omega$ and
$\Omega'$, we can prove that it is also equal to $\dsd{ap}^n(\dsd{ap}
f)$ (with the appropriate coercions inserted).   

Some properties hold only for $n\ge2$.  For example, 
\[
\dsd{ap}^n \: ! \: l = !^n l 
\]
This follows from the Eckmann-Hilton argument, which shows that the
higher homotopy groups are abelian, and that the two different ways of
composing higher-dimensional loops are homotopic.  

\subsubsection{Loops in Types}

For many types $A$, one can give a straightforward characterization of
the paths in $A$.  For example:
\begin{itemize}
\item Paths $f =_{A \to B} g$ are equivalent
to paths $\picl{x}{A}{f x =_B g x}$ by function extensionality.
\item Paths $A
=_\dsd{Type} B$ are equivalent to equivalences between $A$ and $B$ by
univalence.
\item Paths $e_1 =_{A \simeq B} e_2$ between equivalences are equivalent
  to paths $e_1 =_{A \to B} e_2$ (where we implicitly cast $e_i$ from an
  equivalence to a function) because being an equivalence is an hprop.
\end{itemize}

One important piece of the loop space library is an investigation of how
these characterizations extend to higher-dimensional loop spaces.

\paragraph{Functions.}

First, we characterize $\Omega^n(\picl{x}{A}{B},f)$.  For $n=1$, it is
equal to $\picl{x}{A}{} \Omega^n(B, f x)$ by function extensionality.
For $n = 2$, the question is to characterize the type
\[
\dsd{id}_f =_{f =_{\picl{x}{A}{B}} f} \dsd{id}_f
\]
But by \dsd{ap}plying function extensionality (and its action on $\dsd{id}_f$), this type
is equivalent to
\[
\lambda x. \dsd{id}_{f x} =_{\picl{x}{A}{f x =_{B(x)} f x}} \lambda x. \dsd{id}_{f x}
\]
Using function extensionality again, this type is equivalent to
\[
\picl{x}{A} \dsd{id}_{f x} =_{f x =_{B(x)} f x} \dsd{id}_{f x}
\]
which is $\picl{x}{A}{}\Omega^2(B x, f x)$.  

Indeed, in general, we prove
\[
\Omega^n(\picl{x}{A}{B},f) = \picl{x}{A}{}\Omega^n(B(x),f x) 
\]
That is, a loop in a function space is a family of loops.  

\paragraph{Paths between types.}

Second, we characterize $\Omega^n(A =_{\dsd{Type}} A, p)$, where $p$ is
path in the universe from $A$ to $A$.  Consider $n = 1$: by unvialence,
we know that $\Omega(A = A , p)$ is equivalent to $\Omega(A \simeq A, p*)$,
where $p^*$ is the equivalence induced by the path $p$.  But a path
between equivalences is equivalent to a path between the underlying
functions: an equivalence between $A$ and $B$ is a pair $(f , i)$ where
$f : A \to B$ and $i : \dsd{IsEquiv}(f)$, and being an equivalence is an
hprop, so the second components of such pairs are always equal.  Thus, 
\[
\Omega(A = A , p) = \Omega(A \to A, \dsd{coe}(p))
\]
where $\dsd{coe}(p : A = B) : A \to B$---i.e. \dsd{coe} (``coerce'') can be thought
of as turning the path into an equivalence, and then selecting the
``forward'' direction.  We can prove by induction that this rule extends
to higher dimensions, so that 
\[
\Omega^n(A = A , p) = \Omega^n(A \to A, \dsd{coe}(p))
\]

\paragraph{Loop spaces.}

The theorem mentioned above relating $\Omega$ and $\Omega'$ (the different unfoldings of
$\Omega^{1+n}$) also fits this pattern: it characterizes an
$n$-dimensional loop in a loop space as an $1+n$-dimensional loop in the
underlying space:
\[
\Omega^n(\Omega(A),\dsd{id}_a) = \Omega^{1+n}(A,a)
\]

\paragraph{Putting it all together.}  Combining the previous three
lemmas, we have that
\[
\begin{array}{rcll}
\Omega^{1+n}(\dsd{Type},A) & = & 
      \Omega^n(\Omega(\dsd{Type},A) , \dsd{id}_A) & \text{loop in loop space} \\
& = & \Omega^n(A =_{\dsd{Type}} A , \dsd{id}_A) & \text{definition} \\
& = & \Omega^n(A \to A , \lambda x.x) & \text{loop in path between types}\\
& = & \picl{x}{A}{} \Omega^n(A, x) & \text{loop in function type}\\
\end{array}
\]
This is the ``key manuveur'' that we used to define the \dsd{Codes}
fibration in Section~\ref{sec:encode-decode} above.  



\subsubsection{Loops over a Loop}


\ignore{  
  Equiv (Loop n (A → A) (coe p)) (Loop n (Path{Type} A A) p)

  Equiv ((a : A) -> Loop n A a) (Loop (S n) Type A)

  LoopOverS :  (n : Positive) {A : Type} {a : A} (α : Loop (S n) A a) 
             → (B : A -> Type) (b : B a) → Type
  LoopOverS n {A}{a} α B b = 
    Path{Loop n (B a) b} 
        (apt n (ap^ (S n) B α) b)
        (id^ n)

    LoopOverS≃ : (n : Positive) {A : Type} {a : A} (α : Loop (S n) A a) → (B : A -> Type) (b : B a) 
               → LoopOver (S n) α B b ≃ LoopOverS n α B b 

    ap^ (S n) (\ A -> Trunc k A) α ≃ λt n (Trunc-elim (λ tβ → Loop n (Trunc k A) tβ)
                                                      (λ _ → Loop-preserves-level n k Trunc-level) 
                                                      (λ x → ap^ n [_] (apt n α x))) 

    ap^ (S n) (\ A -> Trunc k A) α

    (ap^ (S n) (\ x -> f x ≃ g x) α)

    Loop-Trunc : ∀ (n : Positive) (k : Nat) {A} {a} → Loop n (Trunc (tlp (n +pn k)) A) [ a ] ≃ Trunc (tl k) (Loop n A a)
}

\subsection{Computational Content}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
